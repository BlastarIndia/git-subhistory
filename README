git-subhistory - Interchangeably merge in and split out subtree history

by Han <laughinghan@gmail.com>

INTRO

git-subhistory, like git-submodule and git-subtree, manages subprojects
(call one "Sub") in a superproject (call it "Main") git repo. Like
git-subtree but unlike git-submodule, "Sub's" files are tracked directly
by the "Main" repo, and in fact no other git tools know or care that
"Sub's" directory (call it "path/to/sub/") contains a subproject, as far
as they're concerned it's just another subdirectory of "Main".

Unlike git-submodule and git-subtree, git-subhistory does NOT "need to
[be run] from the toplevel of the working tree", you can run it wherever
you damn well please, even in "path/to/sub/" with . as <subproj-path>.

DESCRIPTIONS

git-subhistory split <subproj-path> [(-b | -B) <subproj-branch>]

  `git-subhistory split` is pretty much the same as `git-subtree split`:
  it generates a completely new, synthetic commit graph of the history
  of just "Sub's" directory. Like the commit history shown by
  `git log --graph "path/to/sub/"`, it includes only commits that
  affected "path/to/sub/", but each commit is rewritten so its root tree
  is the "path/to/sub/" subtree.

git-subhistory merge <subproj-path> <subproj-branch>

  What git-subhistory intends to do better than git-subtree is merging,
  into "Main", commits to "Sub" made outside "Main", by inverting split:
  it looks through the commits on <subproj-branch> for synthetic commits
  that were generated by splitting out some ancestor of HEAD, and then
  on top of the original "Main" commits those synthetic commits were
  generated from, generates more synthetic commits that make the same
  change as the "Sub" commits but to "path/to/sub/" in "Main" instead.

EXAMPLE

This commit graph is what you'd get if you ran these commands:
(commits are represented by, in parens, the files in each commit
 (e.g. what `git ls-files` would print when the commit is checked out);
 branch names clearly point at commits)

    master                    merge-bar
       \                           \
(path/to/sub/foo)<--(path/to/sub/foo, path/to/sub/bar)

         subproj   add-bar
             \         \
            (foo)<--(foo, bar)

(Note 2 disconnected lineages of commits.)

  # 0. setup git repo, empty folders
  git init
  mkdir -p path/to/sub/

  # 1. create and add foo in Sub, commit to Main
  echo foo > path/to/sub/foo
  git add path/to/sub/foo
  git commit -m 'Add path/to/sub/foo'

  # 2. split out commit history of just Sub, rooted in path/to/sub/
  git-subhistory split path/to/sub/ subproj

  # 3. create, add, and commit bar to Sub
  git checkout subproj -b add-bar
  echo bar > bar
  git add bar
  git commit -m 'Add bar'

  # 4. merge in "upstream" commits to Sub
  git checkout master -b merge-bar
  git-subhistory merge path/to/sub/ add-bar

 \   \   |   /   /
- THE COOL THING: -  merge-bar was a fast-forward from master! Even when
 /   /   |   \   \   you do merge --no-ff, master is exactly the right
                     merge base.


COMPARISON WITH GIT-SUBTREE

I actually think git-subtree was halfway there, it got splitting pretty
much right, but then did merging wrong and had to needlessly complicate
splitting to deal with the broken merging. In fact, I started out trying
to fork git-subtree, intending to add an alternative way to merge,
until I discovered that `git-subtree split` was now more complicated
than `git filter-branch --subdirectory-filter`.

This commit graph is what you'd get if you ran the same commands from
the example above but replaced 'git-subhistory' with 'git-subtree -P':

    master
       \
(path/to/sub/foo)<---------------\           merge-bar
                                  \               \
        subproj    add-bar         (path/to/sub/foo, path/to/sub/bar)
            \          \          /
           (foo)<--(foo, bar)<---/

(Note that merge-bar is a merge commit, with 2 parents.)

You can see in the example that the commit creating foo in Main was
split into a commit creating foo in Sub just like you'd expect.
`git-subhistory split` doesn't just serve the same purpose as
`git-subtree split`, it actually does almost exactly the same thing and
often generates identical commits with identical hashes, but is
implemented as a simple `filter-branch --subdirectory-filter`, whereas
git-subtree "manually" loops through history and calls git commit-tree.
I don't know why it does that, but conjecture that using filter-branch
it would be hard to deal with commits that are `merge -s subtree`-ed in
(see below), which are exactly where git-subhistory-generated commits
start diverging from git-subtree-generated commits.

You can see in the example that `git-subtree merge` does something
completely different from `git-subhistory merge`. `git-subtree merge`
actually does `merge --strategy subtree`, which is a fine and dandy
merge option that would let you include Sub in Main very similarly to
git-subhistory: in Main, you can `merge -s subtree` a commit from an
upstream Sub repo, and changes to Sub from there will be merged with
changes to path/to/sub/ in Main. Importantly, as far as git-merge is
concerned it's just some strategy for merging the trees of two commits,
so it normally creates a merge commit whose parents are commits from
each of Main and Sub (notice in the example that the subproject files,
foo and bar, are at different paths between the parents of merge-bar).
If merging in upstream changes is all you need, this is awesome: next
`merge -s subtree`, the last `merge -s subtree`-ed in commit will be the
merge base, and Sub's commit history shows up in Main's commit history.

What is not awesome is that if you commit changes to Sub in the Main
repo, split them out into synthetic commits that get merged into an
upstream Sub repo, and then `merge -s subtree` from upstream Sub back
into Main, the synthetic commits are totally different from the Main
commits that changed Sub, neither is a fast-forward of the other, they
won't be a merge base, and they will both show up in Main's commit
history, essentially duplicating all commits to Sub made in Main (notice
in the example, 2 ancestors of merge-bar created and added foo :( ).

For this reason, most git-subtree tutorials I've seen actually recommend
using --squash when merging, which creates a synthetic commit combining
all the upstream changes to Sub since the last merge, which solves the
duplicate commit problem, but then, no upstream Sub commits are in
Main's history, Main commits are never a fast-forward of any upstream
Sub commits, and there will never be a merge-base. On projects I've
worked on where we wanted to both push and pull commits to and from an
upstream Sub repo (from and to a Main repo), we decided that was worse
than submodules and used submodules instead.
